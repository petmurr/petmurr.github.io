<!DOCTYPE html>
<head>
    <title>Peter Murray</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <!-- All info appears in #content -->
    <div id="content">
        <nav>
            <div onclick="location.href='index.html'" id="nav_logo">
                <h2>Peter Murray</h2> 
                <!-- <p>Aspiring robotics engineer</p> -->
            </div>
            <div onclick="setInnerText(8)" id="nav_armgui" class="project" style="background-image: url(./trajopt/pointmass.gif);">
                <p>Trajectory Optimization</p>
            </div>
            <div onclick="setInnerText(7)" id="nav_wasm" class="project" style="background-image: url(./irwp/thumbnail2.png);">
                <p> Interactive Reaction Wheel Pendulum</p>
            </div>

            <div onclick="setInnerText(5)" id="nav_fsae" class="project" style="background-image: url(./fsae/fsae_epic.png);">
                <p>Formula Electric</p>
            </div>

            <div onclick="setInnerText(2)" id="nav_manim" class="project" style="background-image: url(./rrt/thumbnail.png);">
                <p>Motion Planning Animations</p>
            </div>

            <div onclick="setInnerText(1)" id="nav_armgui" class="project" style="background-image: url(./armgui/thumbnail.png);">
                <p>Robot Arm GUI</p>
            </div>
            

            <!-- <div onclick="setInnerText(3)" id="nav_miren" class="project" style="background-image: url(./miren/thumbnail.png);">
                <p>Musical Air Raid Siren</p>
            </div> -->

            <!-- <div onclick="setInnerText(6)" id="nav_hprc" class="project" style="background-image: url(./hprc/sensorboard_pcb.png);">
                <p>High Powered Rocketry Club</p>
            </div> -->

            <!-- <div onclick="setInnerText(4)" id="nav_kinoplan" class="project" style="background-image: url(./kino/thumbnail.png);">
                <p>Kinodynamic Planning</p>
            </div> -->

        </nav>

        

        <div id="article" class="flex_auto">

            <script type='text/javascript'>
                var Module = {
                preRun: [],
                postRun: [],
                print: (function() {
                    return function(text) {
                        text = Array.prototype.slice.call(arguments).join(' ');
                        console.log(text);
                    };
                })(),
                printErr: function(text) {
                    text = Array.prototype.slice.call(arguments).join(' ');
                    console.error(text);
                },
                canvas: (function() {
                    var canvas = document.getElementById('canvas');
                    //canvas.addEventListener("webglcontextlost", function(e) { alert('FIXME: WebGL context lost, please reload the page'); e.preventDefault(); }, false);
                    return canvas;
                })(),
                setStatus: function(text) {
                    console.log("status: " + text);
                },
                monitorRunDependencies: function(left) {
                    // no run dependencies to log
                }
                };
                window.onerror = function() {
                console.log("onerror: " + event);
                };
            </script>

            <script defer>
                
                // change the page order here, index in json stays the same, just rearrange the mapping and check your work
                // this doesnt need to be a dict
                // oh and you should rearrange navbar, I don't want to rewrite it it's not too bad
                const json2pageorder = {
                    0: 0,   // home
                    1: 7,   // wasm/irwp
                    2: 5,   // fsae
                    3: 2,   // manim/rrt
                    4: 1,   // armgui
                    5: 3,   // miren
                    6: 6,   // hprc
                    7: 4,   // kinoplan
                    8: 8    // trajopt
                };

                const mainTag = document.getElementById("article")
                let currentPage = 0

                function switchLeft() {
                    if (currentPage - 1 < 0) {
                        currentPage = json.length - 1;
                        setInnerText(json2pageorder[currentPage]);
                    } else {
                        currentPage--
                        setInnerText(json2pageorder[currentPage])
                    }
                }

                function switchRight() {
                    if (currentPage + 1 > json.length - 1) {
                        currentPage = 0
                        setInnerText(json2pageorder[currentPage]);
                    } else {
                        currentPage++
                        setInnerText(json2pageorder[currentPage]);
                    }
                    
                }

                const json = [
                    // 0 home
                    {
                        name: "home",
                        articleTitle: `Welcome!`,
                        articleDesc: `
                        <p>
                            Hello! I’m Peter Murray, and I’m looking to design hardware and software for things that move.
                            <br><br>

                        </p>
                        <p>
                            &ensp; Check out my favorite projects: 
                            <br>
                        </p>
                        <p>
                            <a onclick="setInnerText(5)">EV23, WPI’s second ever electric race car</a>, and an <br>
                            <a onclick="setInnerText(7)">interactive inverted reaction wheel pendulum</a>.
                        </p>
                        <p>
                        <br><br>
                            &ensp; I’m open to any discussion of my projects or future work opportunities. Please reach out at <a href="mailto:peter@petermurray.net">peter@petermurray.net</a>. 
                        <br><br>
                            See my <a href="Peter_Murray_Resume_2024.pdf">resume here</a> or below.
                            <br><br>
                            <object data="Peter_Murray_Resume_2024.pdf" type="application/pdf">    
                            </object>
                            <br><br><br><br>
                            You also can also play a game of <a href="minesweeper/minesweeper.html">minesweeper here</a>.    
                        </p>
                        <br>
                        `,
                        imgSrc: `
                        <div class="image" style="background-image: url(peter.jpg);"></div>
                        `,
                        vidSrc: "",
                        misc: ""

                    },
                    // 1 nav_armgui
                    {
                        name: "Armgui",
                        articleTitle: `Armgui`,
                        articleDesc: `
                        <p>
                            &ensp; Armgui is a user interface written in C++ for both windows and linux, built to create an easier way for lab assistants to rapidly test the <a href="https://emanual.robotis.com/docs/en/platform/openmanipulator_x/overview/">OpenManipulatorX</a>, a small-scale serial robotic manipulator used in WPI’s junior level robotics class. Since it doesn’t require any external software, it also provides a great way to demo the robot arm for tour groups or play around with the arm safely without programming experience.
                            <br>
                        </p>
                        <p>
                            <a href="https://github.com/petmurr/armgui">https://github.com/petmurr/armgui</a>
                        </p>
                        <p>
                            &ensp; This is my first relatively complicated C++ program, and my first time working with <a href="https://github.com/ocornut/imgui">Dear ImGui</a>, an immediate-mode graphical user interface library. The <a href="https://github.com/ROBOTIS-GIT/DynamixelSDK">Dynamixel SDK</a> is responsible for talking to the dynamixel servos at a low level, so the program ultimately unites Imgui with the Dynamixel SDK. At a basic level, it looks for a connected serial port, connects to a series of servos, sets the connected servos to the correct mode, and enables the servo's torque when safe to do so. To move the arm into a “home” or “stowed” state, I generate a quintic spline that each servo follows. Each joint can be moved individually with a custom dial implementation after the mouse input has been smoothed to prevent large erroneous inputs. Torque is disabled if the program detects the robot exerting an excessive amount of effort on any of the joints; for example, the robot interfering with itself or an obstacle in its environment. I designed a state machine to manage all the program's functions and outlined a rough outline of the state machine below. 

                        </p>
                        
                        <img src=armgui/armgui_state_diagram.png style="width: 90%"></img>
                        <br><br><br><br>
                        `,
                        imgSrc: `
                            <div class="image" id="quack" style="background-image: url(./armgui/connected_v0.6.png); background-size: contain; background-repeat: no-repeat;"></div>
                        `,
                        vidSrc: "",
                        misc: `
                        
                        `
                    },
                    // 2 nav_manim
                    {
                        name: "Motion Planning Animations",
                        articleTitle: `Motion Planning Animations`,
                        articleDesc: `
                        <p>
                            &ensp; Motion planning is a uniquely visual field of robotics whose fundamental ideas are beautifully spatial and geometric. Taking inspiration from Grant Sanderson’s Manim python library- specifically, <a href="https://www.manim.community/">Manim Community</a>- I created a series of videos that go over the basics of the <b>configuration space</b> and the <b>rapidly exploring random tree</b>, two interesting and fundamental motion planning concepts that lacked any beautiful visual representation.
                        </p>
                        <h2>
                            <br>
                            Configuration Space
                        </h2>
                        <p>
                            &ensp; The configuration space is introduced with a simple robot arm with a single joint and link whose configuration can be completely described by a single number theta that is plotted on a number line. The video then extends this idea to a robot arm with two joints and two links whose configuration can be plotted on a 2D plane. Care is taken to explain the idea of a configuration and the representation of obstacles in each case.
                        </p>
                            <iframe id=cspacevid width="560" height="315" src="https://www.youtube.com/embed/lfIn3FLvhpc?si=didVxy1cZfkTdWZ4" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                        
                        <h2>
                            <br>
                            RRT algorithm
                        </h2>
                        
                        <p>
                            &ensp; With help from my advisor, the RRT lesson is organized in three steps. The first shows the algorithm in action to get a sense of how the RRT algorithm explores its surroundings. The second breaks down the algorithm into its fundamental steps, and the third applies the algorithm to an example to apply each step and explain edge cases as they appear. These videos implement the key animations and are designed to be modular, so can be split into segments and used within a lecture.
                        </p>                
                        <br><br>
                        <h3>RRT Intuition</h3>
                        <video controls="" src="rrt/RRT0_Intuition.mp4" style="width: 90%"></video>        
                        <br><br>
                        <h3>Algorithm Steps</h3>
                        <video controls="" src="rrt/RRT1_Basics.mp4" style="width: 90%"></video>        
                        <br><br>
                        <h3>Example application</h3>
                        <video controls="" src="rrt/RRT2_Application.mp4" style="width: 90%"></video>        
                        <br><br>
                        `,
                        imgSrc: `
                        <video id="rrtvid" autoplay="" loop="" src="rrt/RRT0_Intuition.mp4#t=7,20"></video>
                        `,
                        vidSrc: "",
                        misc: ""
                    },
                    // 3 nav_miren
                    {
                        name: "Miren",
                        articleTitle: `Miren, an attentive musical siren`,
                        articleDesc: `
                        <p>
                            &ensp; Miren (musical siren), is a volume and pitch-controllable air-raid siren. It uses the characteristic rotor and stator found in early 20th century sirens, and boasts the volume to match. The entire mechanical construction consists of a frame, rotor, stator, brushless motor and valve to regulate the volume of air entering the siren.
                        </p>
                        <p>
                            &ensp; Though the integration is incomplete, Miren is capable of 'listening' to its environment, be a passing car or a human's whistle, and identify the notes that it hears, and generate a 'continuation' of what it hears with a modified 2nd order Markov chain having been trained on a collection of 10,000 monophonic midi files.
                        </p>
                        <p>
                            &ensp; Miren uses a wireless protocol to receive pitch and volume trajectory information over long distances. It's capable of reproducing notes from C3 (~130 Hz) to C6# (1109 Hz) and draws around 250 watts during quick, high register requests.
                        </p>
                        <p><a href="miren/Miren_Musical_Robot_Final_Paper.pdf">Report PDF.</a></p>
                        `,
                        imgSrc: `
                        <div class="image" style="background-image: url(./miren/miren_wireframe.png);"></div>
                        `,

                        vidSrc: "",
                        misc: ""
                    },
                    // 4 nav_kinoplan
                    {
                        name: "Kinodynamic_Planner",
                        articleTitle: `Kinodynamic Planning`,
                        articleDesc: `
                        <p>
                            &ensp; An exercise in the fundamental ideas behind kinodynamic motion planning, myself and two teammates wrote a 1, 2 and 3-link planar manipulator simulator and then created a motion planner by implementing the rapdily expanding random tree algorithm in the context of both joint position <i>and</i> joint torque. 
                        </p>
                        <p>
                            &ensp; Our motion planner was principally made from the robot model, our path bounds (start and goal state), our task space (as defined as obstacle boundaries as stored in a CSV), and a state sampler and collision checker. By generating and applying random torques to your arm, adding each new trajectory to a tree, the hope is to rapidly explore your configuration space while being considerate of your physical actuators. On the left, the second gif visualizes this random torque application.
                        </p>
                        <p>
                            &ensp; Written entirely in python using an unoptimized RRT algorithm, our implementation was painfully slow. Branches would grow on the scale of minutes. Simulating our arm forward in time based on randomly generated torque values introduced a great deal of extra parameters to tune, and our manhattan distance function's poor performance in higher dimensional space is also to blame.
                        </p>
                        `,
                        imgSrc: `
                        <div class="kino_article_box">
                            <div class="newimage" id="kino1" style="background-image: url(./kino/2link.gif)"></div>
                            <div class="newimage"  id="kino2" style="background-image: url(./kino/3link.gif)"></div>
                        </div>
                        `,
                        vidSrc: "",
                        misc: ""
                    },
                    // 5 nav_fsae
                    {
                        name: "FSAE",
                        articleTitle: `Formula Electric 2023`,
                        articleDesc: `
                            <p>
                                &ensp; EV23 is WPI's electric racecar that raced at the 2023 Formula Hybrid + Electric competition, and <a href="https://www.formula-hybrid.org/history/2023">tied for third overall</a>. I worked with some incredibly talented engineers, and was a member of battery subteam.
                                <br><br>
                            </p>
                            <h2>Accumulator Redesign</h2>
                            <img src=fsae/fsae_rear.png style="width: 80%"></img>
                            <p>
                                &ensp; Over a school year we conceptualized, modeled, and manufactured entirely new accumulator enclosure, mounting system, and cooling system. We adapted the battery segments to be both more structurally sound as well as modular, drastically improving the time required to assemble and disassemble the accumulator. The modularity in combination with the ability to bypass a segment allowed us to keep our car in the competition in the event of an unforeseen failure. <br><br>
                            </p>
                            <br>
                            <br>
                            <img src=fsae/busbars.png style="width: 90%"></img>
                            <br>
                            <img src=fsae/segment_rails.png style="width: 50%"></img>
                            <br>
                            <p>
                                &ensp; We designed and built segment rails to adapt the cell segments used in the year previous into our new enclosure. Each segment slides into tracks made from slippery UMHW on the top and bottom of the center of the enclosure. When the rear panel is installed, all the segments are connected in series. Each segment is identical, and can be swapped with any other. In the case of a segment failure, we can swap a busbar that connects only three segments in series to keep our car from dropping from the competition entirely. The panel design has the added benefit of guaranteeing the accumulator is unpowered when opened for service.
                            </p>
                            <h2><br>Machining Firsts</h2>
                            <img src=fsae/garolite_double.png style="width:90%"></img>
                            <br>
                            <p>
                                &ensp; I had the opportunity to have a few machining firsts when the accumulator was coming together late in the year. These cell segments are required to be isolated between fire resistant garolite sheets, which in the case of an emergency, prevent the accumulator from burning too quickly. Since cutting fiberglass is notorious for wearing out tools and throwing irritating dust everywhere, these were a little more difficult to make. We ended up bagging an entire tabletop CNC machine, using water to cut down on the dust, and wore goggles, a respirator, and a spare set of clothes.
                                
                                
                            </p>
                            <br>
                            <br>
                            <img src=fsae/hass_tm_fixturing2.png style="width: 70%"></img>
                            <br>
                            <img src=fsae/hass_tm_fixturing.jpg style="width: 70%"></img>
                            <br>
                            <p>
                                &ensp; When I made the intake fan manifold, aptly named the fanifold, I spent a great deal of time learning about fixturing with the Hass tool room mill cutting 1/8th inch polycarbonate sheets.
                            </p>

                            <img src=fsae/fanifold_double.png style="width: 80%"></img>
                            <br><br>
                            <p>
                                Thanks for reading this far! I also have a video of EV22, back when we were testing it. It had really long control arms.
                            </p>

                            <iframe width="560" height="315" src="https://www.youtube.com/embed/EYLcYSEN-HY?si=ZKV9ksa1Diul80EM" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>

                        
                        `,
                        imgSrc: `
                        <div class="image" id="fsae1" style="background-image: url(./fsae/fsae_epic.png)"></div>
                        `,
                        vidSrc: "<video muted autoplay src='fsae.webm' type='video/webm'></video>",
                        misc: `
                        <div class="misc">
 
                        </div>
                        `
                    },
                    // 6 nav_hprc
                    {
                        name: "HPRC",
                        articleTitle: `High Powered Rocketry Club`,
                        articleDesc: `
                        <p>
                            &ensp; Helped design, build and debug the sensor board for HPRC's <i>The Stack:</i> a series of four separate PCBs, each dedicated to a key function necessary for our rocket. These four boards communicated with one another over CAN- among them, the <b>power board</b> for power regulation and voltage control, the <b>telemetry board</b> for LoRA radio communication, the <b>controller board</b>, responsible for interfacing with a micomod teensy for state estimation and airbrake control, and the <b>sensor board</b>, a board dedicated to interfacing with an IMU, Barometer, Magnetometer and GPS.
                        </p>
                        <p>
                            &ensp; The sensor board made use of both a 3.3v and 5v pour and is made of a total of four layers. Since we used CAN, each board needed its own CAN controller and transceiver as well as its own microprocessor- three of the four boards had a dedicated ATMEGA328. CAN ended up being a large hurdle to both the electronics design team as well as the embedded system team due to the volume of data produced by our sensors after parsing the data, which required a great deal of work to send correctly. 
                        </p>
                        <p>
                            &ensp; This design was eventually scrapped for a much simpler, single board, which removed a huge amount of overhead from our CAN device drivers, so the stack never got to fly. However, the stack remains in our hearts. And it looks awesome.
                        </p>
                        `,
                        imgSrc: `
                        <div class="newimage" id="hprc1" style="background-image: url(./hprc/stack.png)"></div>
                        `,
                        vidSrc: "",
                        misc: ""
                    },
                    // 7 nav_wasm
                    {
                        name: "WASM",
                        articleTitle: `Inverted Reaction Wheel Pendulum`,
                        articleDesc: `

                        <p>
                            &ensp; Press the "nudge" buttons to see the controller stabilize the input! I created this with Dear Imgui, and compiled it to WebAssembly using Emscripten. This simulation is using a state space controller using pole placement, and uses Euler's method to propagate dynamics over time. It's unrealistic, but fun to see in action.
                        </p>
                        <h2>Simulation vs Real-World</h2>
                        <iframe width="560" height="315" src="https://www.youtube.com/embed/q-3DYe_nyH0?si=8zRCaPbPAhOW2Sg0" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                        <p>
                            <br>
                            &ensp; This is an inverted pendulum with a reaction wheel attached at one end. Reaction wheels are often found in spacecraft for attitude control since they can precisely apply a torque to the craft they’re attached to by spinning up or slowing down. We can take advantage of this functionality by placing a reaction wheel at the end of a pendulum to stabilize it in the upright configuration.
                            <br><br>
                        </p>
                        <img src=irwp/model_drawn.png style="width: 50%"></img>
                        <p>
                            &ensp; Since an inverted pendulum is a highly unstable system, you have to be careful with the way you apply a torque to stabilize it. Above is a simulation that is implementing a “state space controller”, a controller that generates some output torque based on the system’s full “state,” in our case, the pendulum’s angle, the wheel’s angle, pendulum’s angular velocity, and the wheel’s angular velocity. I first found the equations of motion of the system by using the Lagrangian formulation of dynamics and then linearized the system about the equilibrium point of the pendulum in the upright configuration. I then used pole placement to find appropriate gain matrices that, when multiplied by the state vector, calculate an exact torque that will stabilize the pendulum in the upright configuration. 
                            <br><br>
                            &ensp; This analysis was all in preparation for implementation on a real-world version of the system, but the real world integration of the controller was immensely difficult due to model mismatch and unmodeled dynamics of my motor. To see if it was possible at all, I tried implementing a simpler PID controller, which I eventually got to work.
                            <br><br><br><br>
                        </p>
                        `,
                        imgSrc: `
                                <iframe src="./wasm/index.html" class="emscripten-iframe" id="iframe" style="width:100%; height:100%; border:none;"></iframe>
                                `,
                        vidSrc: "",
                        misc: ""
                    },
                    // 8 nav_trajopt
                    {
                        name: "trajopt",
                        articleTitle: "Stabilizing Trajectories",
                        articleDesc: `
                        <p>
                            &ensp; As part of my exploration into spacecraft landing dynamics, I've implemented a time-varying LQR controller for a simple system, a thrust-vector controlled point mass. Russ Tedrake’s publicly available <a href="https://underactuated.csail.mit.edu/">Underactuated Robotics lectures</a> helped me connect the dots between fundamental control theory and  complex maneuvers. The challenge involved managing a nonlinear dynamic system in state-space form, where a trajectory optimizer planned a viable path for the system to take with certain initial and final conditions, minimizing a cost function that restricts fuel usage. In a simulation, the controller robustly drives the point mass across this trajectory by finding the time-varying gain necessary to stabilize the system. 
                        </p>
                        <h2><br>Trajectory Optimization is Magic</h2>
                        <iframe width="560" height="315" src="https://www.youtube.com/embed/6qj3EfRTtkE?si=PfoVClPJbMdSFm0d" title="YouTube video player" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
                        <br><br>
                        <p> 
                            &ensp; If you’ve ever seen a quadrotor do a flip, a spaceship land softly or a robot doing a somersault, there’s a good chance it was created with trajectory optimization. I recently found it through an impressive demo that Thomas Godden published that created an animation that matched SN15’s belly flop maneuver with a surprising level of accuracy. <a href="https://thomasgodden.com/starship-trajopt.html">He wrote a great article about it on his website.</a>. He used CasADi, an open source optimization library that makes it easy to formulate and solve an optimization problem. 
                        </p>
                        <p>
                            &ensp; In control classes, you will be taught how to stabilize systems with a control input such that it remains at a setpoint- to not move, with the goal of being robust to external disturbances. An inverted pendulum is a great way to get a sense for this; the pendulum in the upright configuration is inherently unstable and requires a corrective force for even small disturbances. But what if you wanted to find a way to move a pendulum from the downwards to the upwards configuration?
                        </p>
                        <img src=trajopt/cartpole.gif style="width: 90%; filter: none;"></img>
                        <p>
                            &ensp; Trajectory optimization solves this by transitioning the system from an initial to a final state while minimizing a cost function. It does this by slicing the trajectory (the pendulum’s angle and control input) into many discrete time intervals and then “changes” an input to see what sequence of inputs can drive the pendulum towards its goal. It does this whole process while calculating the cost of each sequence of inputs, which in our case translates to penalizing large input forces, and iterates until it finds the one with the least amount of cost used. I’m aware I’m being vague about how exactly an optimizer “changes a control input” because it implements some complicated iterative algorithms that involve calculating gradients of the cost function, searching a large area of possible solutions and eventually converging to a locally optimal solution if it exists. Each time step, it makes sure the dynamics of the system are obeyed: that the next state of the system is equal to the current state + the derivative of the state * dt, and if you choose to do so, limits the minimum and maximum control inputs possible to apply. 
                        <br><br><br>
                            &ensp; It’s surprisingly simple to formulate and solve a problem in CasADi, and I highly recommend you take a look at the code I wrote to find a “swing-up” and “swing-down” trajectory for the cart-pole system above.  Briefly, it defines the dynamics of the system, declares decision variables for the state of the cartpole (what position the cart and pole are in and how fast they’re moving), then defines a cost function, limits the controls to a maximum and minimum, and finally uses a solver to calculate the solution.
                        </p>
                        <h2><br>Trajectories are just a series of numbers</h2>
                        <p>
                            &ensp; Here’s an important detail: trajectory optimization is offline. That means the system can’t stabilize an active simulation or real-world hardware, because it’s simply a sequence of numbers. If you applied the sequence of inputs to a real-world cart-pole, or even a simulated cart-pole, it will just fall over. This is where trajectory stabilization can be used- since you already know the sequence of steps to take, you can construct a time-varying controller capable of making the system robust to external disturbances along the entire path the system takes. 
                        </p>
                        <h2><br>tvLQR control of a Thrust-vectored Point-mass</h2>
                        <p>
                            I chose to try and develop a time-varying LQR controller after modeling a simple system: a point-mass with a rotatable thruster.
                        <br>
                        </p>
                        <img src=trajopt/pointmass.gif style="width: 40%; filter: none;"></img>
                        <p>
                            Precomputed thrust-vectored point-mass trajectory.
                        </p>
                        <img src=trajopt/matlab_traj.png style="width: 60%; filter: none;"></img>
                        <p>
                            Actively controlled thrust-vectored point-mass.
                        </p>
                        <br><br><br>
                        <p>
                            &ensp;Given the state vector X (our pointmass’s position and velocity in the x and y directions) we find a gain matrix K such that the equation u = -K * x drives our system to a desired state. This is the fundamental idea behind state space control, and there’s a clever way to calculate K that takes into consideration both actuator effort- the magnitude of our inputs- and our controllers performance- how large our errors are. I won’t be describing how LQR control works in detail, but there are a lot of great resources out there, like <a href="https://www.youtube.com/watch?v=E_RDCFOlJx4">Brian Douglas’s excellent tech talk series</a>. What’s important is that if we have a linearized version of our system’s dynamics, it’s simple to calculate the gain matrix K with Matlab’s icare() function, which computes the closed-form algebraic riccati equation. 
                            <br><br>
                            &ensp;To make this time varying, I use the 200 steps in our trajectory to linearize 200 separate state space equations that each are assigned a gain matrix. Now we can have our system perform a maneuver online. Within a simulation, the gain matrices we computed will spit out just the right amount of input to stabilize the system at that time interval- at the next time interval, it uses the subsequent gain matrix. From here, we can add disturbances to see how well the controller performs. In this case, I initialized the system at a point a meter away from the trajectory’s actual initial position- in the graph above, you can see how the solid blue line, representing the point-mass’s actual trajectory initially starts a little bit away from the red dotted line, but then overlaps it but converges within a few seconds. There are more sophisticated ways of testing controllers like modeling sensor noise, polluting our input signal with noise, and seeing how far away from the starting point the controller can converge from. While this is far from a practical hardware implementation, I'm happy to have uncovered some of the mystery of how engineers have made spacecraft <i>land</i>.

                        </p>
                        `,
                        imgSrc: `
                        <div class="image" style="background-image: url(trajopt/pointmass.png)"></div>
                        `,
                        misc: ""
                    }
                ]

                function setInnerText(pageNumber) {
                    mainTag.innerHTML = `
                        
                        <div class="article_title">

                            <h1>${json[pageNumber].articleTitle}</h1>

                        </div>

                        <div class="article_image">

                            ${json[pageNumber].imgSrc}

                        </div>
                        
                        <div class="article_desc">

                            ${json[pageNumber].articleDesc}

                        </div>

                        <div class="misc">
                            
                            ${json[pageNumber].misc}
                        
                        </div>
                        
                    `
                    
                    // Change the color to indicate which page you're on
                    switch (pageNumber) {
                        case 1:
                            changeColor("nav_armgui");
                            break;
                        case 2:
                            changeColor("nav_manim");
                            break;
                        case 3:
                            changeColor("nav_miren");
                            break;
                        case 4:
                            changeColor("nav_kinoplan");
                            break;
                        case 5:
                            changeColor("nav_fsae");
                            break;
                        case 6:
                            changeColor("nav_hprc");
                            break;
                        case 7:
                            changeColor("nav_wasm");
                            break;
                        case 8:
                            changeColor("nav_trajopt");
                            break;
                        default:
                            changeColor("lolol");
                    }

                }

                function changeColor(targetId) {
                    var ids = [
                        "nav_armgui", 
                        "nav_manim", 
                        "nav_miren", 
                        "nav_kinoplan", 
                        "nav_fsae", 
                        "nav_hprc", 
                        "nav_wasm",
                        "nav_trajopt"];

                    ids.forEach(function(id) {
                        var div = document.getElementById(id);
                        if (id === targetId) {
                            div.style.backgroundColor = "#243139";
                        } else {
                            div.style.backgroundColor = '';
                        }
                    });
                }

                // Function to get URL parameters
                function getUrlParameter(name) {
                    const urlParams = new URLSearchParams(window.location.search);
                    return urlParams.get(name);
                }

                // change these to link to certain page from elsewhere
                // e.g. https://petermurray.net/?page=irwp
                const pageMap = {
                    'armgui': 1,
                    'rrt': 2,
                    'fsae': 5,
                    'irwp': 7,
                    'hprc': 6,
                    'kino' : 4,
                    'trajopt': 8
                };

                let max_page_idx = 7;

                function getPageFromParam(param) {
                    // Check if the parameter is a key in the pageMap
                    if (pageMap.hasOwnProperty(param)) {
                        return pageMap[param];
                    }
                    // Attempt to convert param to a number
                    const pageNumber = parseInt(param, 10);
                    return !isNaN(pageNumber) && pageNumber >= 0 && pageNumber <= max_page_idx ? pageNumber : null;
                }

                const pageParam = getUrlParameter('page');
                const page = getPageFromParam(pageParam);

                if (page !== null) {
                    setInnerText(page);
                } else {
                    // Default to page 0 if no valid parameter is set
                    setInnerText(0);
                }

            </script>
        </div>
    </div>
</body>